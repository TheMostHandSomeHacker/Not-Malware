#pragma once
#include<stdio.h>
#include<iostream>
#include<Windows.h>
//#include "Custom_Function.h"
using namespace std;

#define DEREF(name) *(UINT_PTR*)(name)
#define DEREF_64(name) *(DWORD64*)(name)
#define DEREF_32(name) *(DWORD*)(name)
#define DEREF_16(name) *(WORD*)(name)
#define DEREF_8(name) *(BYTE*)(name)

int m_memcmp(const void* buf1, const void* buf2, size_t count)
{
	if (!buf1 || !buf2)
	{
		return -1;
	}

	unsigned char* p1 = (unsigned char*)buf1;
	unsigned char* p2 = (unsigned char*)buf2;

	int   rc = 0;

	for (size_t i = 0; i < count; i++)
	{
		if (*p1 < *p2)
		{
			rc = -1;
			break;
		}

		if (*p1 > *p2)
		{
			rc = 1;
			break;
		}

		p1++;
		p2++;
	}

	return rc;
}


FARPROC removing_Hook(char* apiFromGetModule, char *dllName) {
	char modulePath[MAX_PATH];
	HANDLE hfile = NULL;
	PIMAGE_DOS_HEADER dosHeader;
	HMODULE handle;
	PVOID apiFromDisk = NULL;

	handle = pLoadLibraryA(dllName);
	if (handle == INVALID_HANDLE_VALUE) {
		cout << "Invalid handle value...\n";
		return NULL;
	}
	pGetModuleFileNameA(handle, modulePath, MAX_PATH); // C:\\User\\System32\\<path>

	hfile = pCreateFileA(modulePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hfile == INVALID_HANDLE_VALUE) {
		cout << "Can not read file\n";
		pCloseHandle(hfile);
		return NULL;
	}

	DWORD fileSize = pGetFileSize(hfile, NULL);
	if (fileSize == INVALID_FILE_SIZE) {
		cout << "File size not invalid\n";
		pCloseHandle(hfile);
		return NULL;
	}

	HANDLE hMapFile = pCreateFileMappingA(hfile, NULL, PAGE_READONLY | SEC_IMAGE, 0, 0, NULL);
	if (hMapFile == NULL) {
		cout << "Can not map file\n";
		pCloseHandle(hfile);
		return NULL;
	}

	LPVOID dllBuffer = pMapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);
	if (dllBuffer == NULL) {
		pCloseHandle(hfile);
		pCloseHandle(hMapFile);
		return NULL;
	}

	dosHeader = (PIMAGE_DOS_HEADER)dllBuffer;
	if (dosHeader == NULL) {
		pUnmapViewOfFile(dllBuffer);
		pCloseHandle(hfile);
		pCloseHandle(hMapFile);
		return NULL;
	}

	IMAGE_NT_HEADERS* NtHeader = (PIMAGE_NT_HEADERS)((PBYTE)dllBuffer + dosHeader->e_lfanew);
	IMAGE_OPTIONAL_HEADER* OptionalHeader = (PIMAGE_OPTIONAL_HEADER) & (NtHeader->OptionalHeader);
	IMAGE_EXPORT_DIRECTORY* ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)dllBuffer + OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
	ULONG* AddressOfFunctions = (PULONG)((PBYTE)dllBuffer + ExportDirectory->AddressOfFunctions);
	ULONG* AddressOfNames = (PULONG)((PBYTE)dllBuffer + ExportDirectory->AddressOfNames);
	USHORT* AddressOfNameOrdinals = (PUSHORT)((PBYTE)dllBuffer + ExportDirectory->AddressOfNameOrdinals);

	for (DWORD i = 0; i < ExportDirectory->NumberOfNames; i++) {
		PCSTR name = (PSTR)((PBYTE)dllBuffer + AddressOfNames[i]);
		if (strcmp(name, apiFromGetModule) == 0) {
			apiFromDisk = (PSTR)((PBYTE)dllBuffer + AddressOfFunctions[AddressOfNameOrdinals[i]]);
			break;
		}
	}

	if (apiFromDisk == NULL) {
		pUnmapViewOfFile(dllBuffer);
		pCloseHandle(hfile);
		pCloseHandle(hMapFile);
		return NULL;
	}

	HMODULE hTargetDLL = pGetModuleHandleA(dllName);
	if (hTargetDLL == NULL) {
		pUnmapViewOfFile(dllBuffer);
		pCloseHandle(hfile);
		pCloseHandle(hMapFile);
		return NULL;
	}

	FARPROC targetAPI = (FARPROC)pGetProcAddress(hTargetDLL, apiFromGetModule);
	if (targetAPI == NULL) {
		pUnmapViewOfFile(dllBuffer);
		pCloseHandle(hfile);
		pCloseHandle(hMapFile);
		return NULL;
	}

	if (memcmp(targetAPI, apiFromDisk, 16) != 0) {
		cout << "cave!!\n";
		DWORD oldProtection, ERWProtection;
		pVirtualProtect(targetAPI, 10, PAGE_EXECUTE_READWRITE, &oldProtection);
		memcpy(targetAPI, apiFromDisk, 10);
		pVirtualProtect(targetAPI, 10, oldProtection, &ERWProtection);
	}
	pUnmapViewOfFile(dllBuffer);
	pCloseHandle(hfile);
	pCloseHandle(hMapFile);
	return targetAPI;
	
}


